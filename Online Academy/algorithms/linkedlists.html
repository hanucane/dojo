<head>
    <title>Linked Lists</title>
</head>

<script>
// Object Constructor concept - Blueprint
function SLNode(value){
    this.val = value;
    this.next = null;
}

function SLList(){
    this.head = null;
    // ...other properties...
}

node1 = new SLNode(1);
node2 = new SLNode(2);
node3 = new SLNode(3);
node4 = new SLNode(4);

node1.next = node2;
node2.next = node3;
node3.next = node4;


// addBack
function addBack(node, value){
    if(node){
        temp = node;
        while(temp.next){
            temp = temp.next;
        }
        temp.next = { val: value, next: null }
    }
}
addBack(node1, 5)
console.log(node1)

// addFront
// Given a pointer to the first node in a list, and a value, create a new node, connect it to the head of the list, and return a pointer to the list’s new head node.
// addFront(Node, Number) => Node
function addFront(node, value){
    temp = {val: value, next: node};
    console.log(temp)
}
addFront(node1, 8)

// removeFront
// Given a pointer to the first node in a list, remove the head node and return the new list. If list is empty, return null.
// removeFront(Node) => Node
function removeFront(node){
    temp = node.next;
    console.log(temp)
}
removeFront(node1)

// contains
// Given a pointer to a listNode and a value, return whether value is found in any node within the list
// contains(Node, Number) => Boolean
function contains(node, value){
    while(node.next){
        if(node.val === value){
            return console.log(Boolean(node.val === value));
            
        }
        node = node.next;
    }
    if(node.val !== value){
        return console.log(Boolean(node.val === value))
    }
}
contains(node1, 6)
contains(node1, 2)

// front
// Return the value (not the node) at the head of the list. If list is empty, return null.
// front(Node) => Number


// length
// Create a function that accepts a pointer to first list node, and returns number of nodes in sList. 

// average
// Create a standalone function average(node) that returns (…wait for it … ) the average of all values contained in that list.

// min, max
// Create function min(node) and max(node) to returning smallest and largest values in the list.

// display
// Create display(node) for debugging that returns a string containing all list values. Build what you wish console.log(myList) did!

// prependVal
// Create prependVal(list,value,before) that inserts a new node with given value immediately before the node with before (or at end). Return the new list. 

// removeVal
// Create removeVal(list,value) that removes from our list the node with the given value. Return the new list.

// appendVal
// Create appendVal(list,value,after) that inserts a new listNode with given value immediately after the node containing after (or at end). Return the new list. 

// splitOnVal
// Create splitOnVal(list,num) that, given number, splits a list in two. The latter half of the list should be returned, starting with node containing num. E.g.: splitOnVal(5) for the list (1 >3>5>2>4) will change list to (1>3) and return value will be (5>2>4). 
// Given: (1)->(2)->(3)->(4), 3
// Return: (3)->(4)

// partition
// Create partition(list,value) that locates the first node with that value, and moves all nodes with values less than that value to be earlier, and all nodes with values greater than that value to be later. Otherwise, original order need not be perfectly preserved. 
// Given: (3)->(1)->(2)->(4)->(5)
// Return: (1)->(2)->(3)->(4)->(5)
// Given: (10)->(15)->(11)->(4)->(9)
// Return: (4)->(9)->(10)->(15)->(11)

// deleteGivenNode
// Create listNode method removeSelf() to disconnect (remove) itself from linked lists that include it. Note: the node might be the first in a list, and you do NOT have a pointer to the previous node. Also, don’t lose any subsequent nodes pointed to by .next.

</script>